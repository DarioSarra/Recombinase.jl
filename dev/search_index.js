var documenterSearchIndex = {"docs":
[{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"EditURL = \"https://github.com/piever/Recombinase.jl/blob/master/docs/src/digging_deeper.jl\"","category":"page"},{"location":"generated/digging_deeper/#Digging-deeper-1","page":"Digging deeper","title":"Digging deeper","text":"","category":"section"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"The core functioning of Recombinase is based on a set of preimplemented analysis functions and on the OnlineStats package to compute summary statistics efficiently.","category":"page"},{"location":"generated/digging_deeper/#Analysis-functions-1","page":"Digging deeper","title":"Analysis functions","text":"","category":"section"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"Under the hood, the actual computations are implemented in some built-in Analysis objects. Each Analysis takes some vectors (a varying number, one for density and two for prediction for example), an optional axis argument to specify the x axis argument and returns an iterator of (x, y) values, representing the y value corresponding to each point of the x axis.","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using Recombinase: density, hazard, cumulative, prediction\nx = randn(100)\nres = density(x)\ncollect(Iterators.take(res, 5)) # let's see the first few elements","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"We can collect the iterator in a table container to see that we recover the x and y axis, ready for plotting","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using JuliaDB\ns = table(res)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"prediction is similar but requrires two arguments:","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"xs = 10 .* rand(100)\nys = sin.(xs) .+ 0.5 .* rand(100)\n\nres = prediction(xs, ys)\ntable(res)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"The function discrete can turn any analysis into its discrete counter-part (analyses are continuous for numerical axes and discrete otherwise by default). It also automatically comutes the error of the prediction (s.e.m).","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using Recombinase: discrete\n\nx = rand(1:3, 1000)\ny = rand(1000) .+ 0.1 .* x\n\nres = discrete(prediction)(x, y)\ntable(res)","category":"page"},{"location":"generated/digging_deeper/#OnlineStats-integration-1","page":"Digging deeper","title":"OnlineStats integration","text":"","category":"section"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"Summary statistics are computed using the excellent OnlineStats package. First the data is split by the splitting variable (in this case School), then the analysis is computed on each split chunk on the selected column(s). Finally the results from different schools are put together in summary statistics (default is mean and s.e.m):","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using Recombinase: datafolder, compute_summary\ndata = loadtable(joinpath(datafolder, \"school.csv\"))\ncompute_summary(density, data, :School; select = :MAch)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"Any summary statistic can be used. If we only want the mean we can use","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using OnlineStats\ncompute_summary(density, data, :School; select = :MAch, stats = Mean())","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"We can also pass a Tuple of statistics to compute many at the same time:","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using OnlineStats\ncompute_summary(density, data, :School; select = :MAch, stats = Series(Mean(), Variance()))","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"One can optionally pass pairs of OnlineStat and function to apply the function to the OnlineStat before plotting (default is just taking the value). To compute a different error bar (for example just the standard deviation) you can simply do:","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"stats = (Mean(), Variance() => t -> sqrt(value(t)))\ncompute_summary(density, data, :School; select = :MAch, stats = stats)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interactive_interface/#Interactive-interface-1","page":"Interactive interface","title":"Interactive interface","text":"","category":"section"},{"location":"interactive_interface/#","page":"Interactive interface","title":"Interactive interface","text":"Most of the available analyses can be selected from a simple Interact-based UI. To launch the UI simply do:","category":"page"},{"location":"interactive_interface/#","page":"Interactive interface","title":"Interactive interface","text":"using Recombinase, Interact, StatsPlots, Blink\n# here we give the functions we want to use for plotting\nui = Recombinase.gui(data, [plot, scatter, groupedbar]);\nw = Window()\nbody!(w, ui)","category":"page"},{"location":"interactive_interface/#","page":"Interactive interface","title":"Interactive interface","text":"(Image: interactgui)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/piever/Recombinase.jl/blob/master/docs/src/tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, let us load the relevant packages and an example dataset:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Statistics, StatsBase, StatsPlots, JuliaDB\nusing OnlineStats: Mean, Variance\nusing Recombinase\nusing Recombinase: cumulative, density, hazard, prediction\n\ndata = loadtable(joinpath(Recombinase.datafolder, \"school.csv\"))","category":"page"},{"location":"generated/tutorial/#Simple-scatter-plots-1","page":"Tutorial","title":"Simple scatter plots","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Then we can compute a simple scatter plot of one variable against an other. This is done in two steps: first the positional and named arguments of the plot call are computed, then they are passed to a plotting function:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    select = (:MAch, :SSS),\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"This creates an overcrowded plot. We could instead compute the average value of our columns of interest for each school and then plot just one point per school (with error bars representing variability within the school):","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    error = :School,\n    select = (:MAch, :SSS),\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"By default, this computes the mean and standard error, we can pass stats = Mean() to only compute the mean.","category":"page"},{"location":"generated/tutorial/#Splitting-by-many-variables-1","page":"Tutorial","title":"Splitting by many variables","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can use different attributes to split the data as follows:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(color = :Sx, markershape = :Sector),\n    error = :School,\n    select = (:MAch, :SSS),\n    stats = Mean(),\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#Styling-the-plot-1","page":"Tutorial","title":"Styling the plot","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"There are two ways in which we can style the plot: first, we can pass a custom set of colors instead of the default palette:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    error = :School,\n    select = (:MAch, :SSS),\n    stats = Mean(),\n    color = [:red, :blue]\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Second, we can style plat attributes as we would normally do:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    error = :School,\n    select = (:MAch, :SSS),\n    stats = Mean(),\n    )\nscatter(args...; legend = :topleft, markersize = 10, kwargs...)","category":"page"},{"location":"generated/tutorial/#Computing-summaries-1","page":"Tutorial","title":"Computing summaries","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"It is also possible to get average value and variability of a given analysis (density, cumulative, hazard rate and local regression are supported so far, but one can also add their own function) across groups.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"For example (here we use ribbon to signal we want a shaded ribbon to denote the error estimate):","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    cumulative,\n    data,\n    Group(:Sx),\n    error = :School,\n    select = :MAch,\n    ribbon = true\n   )\nplot(args...; kwargs..., legend = :topleft)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note that extra keyword arguments can be passed to the analysis:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    density(bandwidth = 1),\n    data,\n    Group(color=:Sx, linestyle=:Sector),\n    error = :School,\n    select = :MAch,\n    ribbon = true\n   )\nplot(args...; kwargs..., legend = :bottom)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"If we do not specify error, it defaults to the \"analyses specific error\". For discrete prediction it is the standard error of the mean across observations.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    prediction,\n    data,\n    Group(color = :Minrty),\n    select = (:Sx, :MAch),\n)\ngroupedbar(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#Axis-style-selection-1","page":"Tutorial","title":"Axis style selection","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Analyses try to infer the axis type (continuous if the variable is numeric, categorical otherwise). If that is not appropriate for your data you can use discrete(prediction) or continuous(prediction) (works for hazard, density and cumulative as well). A special type of axis type is vectorial: the x and y axes can be contain AbstractArray elements, in which case we take views of elements of y corresponding to elements of x. This can be useful to compute averages of time varying signals.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Recombinase: offsetrange\nsignal = sin.(range(0, 10π, length = 1000)) .+ 0.1 .* rand.()\nevents = range(50, 950, step = 100)\nz = repeat([true, false], outer = 5)\nx = [offsetrange(signal, ev) for ev in events]\ny = fill(signal, length(x))\nt = table(x, y, z, names = [:offsets, :signals, :peak])\n\nargs, kwargs = series2D(\n    prediction(axis = -60:60),\n    t,\n    Group(:peak),\n    select = (:offsets, :signals),\n    ribbon = true,\n)\nplot(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#Post-processing-1","page":"Tutorial","title":"Post processing","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Finally, for some analyses it can be useful to postprocess the result. For example, in the case of the \"signal plot\" above, we may wish to rescale the x axis. This is done by passing a named tuple of functions as a postprocess keyword argument, which will be applied element-wise to the relative column of the output. For example, if our signal was sampled at 60 Hz, we may wish to divide the :offsets column by 60 to show the result in seconds:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    prediction(axis = -60:60),\n    t,\n    Group(:peak),\n    select = (:offsets, :signals),\n    ribbon = true,\n    postprocess = (; offsets = t -> t/60),\n)\nplot(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"Recombinase allows to do simple data analyses and visualizations in Julia, especially in the case of grouped data.","category":"page"},{"location":"#Getting-started-1","page":"Index","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"To install Recombinase, simply activate the package REPL with ] in the Julia console and then add the package using the repository URL:","category":"page"},{"location":"#","page":"Index","title":"Index","text":"julia> ]\npkg> add https://github.com/piever/Recombinase.jl.git","category":"page"},{"location":"#","page":"Index","title":"Index","text":"See the Tutorial for a quick guide on how to use this package.","category":"page"}]
}
