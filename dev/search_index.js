var documenterSearchIndex = {"docs":
[{"location":"#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"Recombinase allows to do simple data analyses and visualizations in Julia, especially in the case of grouped data.","category":"page"},{"location":"#Getting-started-1","page":"Index","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"To install Recombinase, simply activate the package REPL with ] in the Julia console and then add the package using the repository URL:","category":"page"},{"location":"#","page":"Index","title":"Index","text":"julia> ]\npkg> add https://github.com/piever/Recombinase.jl.git","category":"page"},{"location":"#","page":"Index","title":"Index","text":"See the Tutorial for a quick guide on how to use this package.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/piever/Recombinase.jl/blob/master/docs/src/tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, let us load the relevant packages and an example dataset:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Statistics, StatsBase, StatsPlots, JuliaDB\nusing OnlineStats\nusing Recombinase: Group, series2D, datafolder\nusing Recombinase: compute_summary, discrete, density, hazard, cumulative, prediction\n\ndata = loadtable(joinpath(datafolder, \"school.csv\"))","category":"page"},{"location":"generated/tutorial/#Simple-scatter-plots-1","page":"Tutorial","title":"Simple scatter plots","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Then we can compute a simple scatter plot of one variable against an other. This is done in two steps: first the positional and named arguments of the plot call are computed, then they are passed to a plotting function:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    select = (:MAch, :SSS),\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"This creates an overcrowded plot. We could instead compute the average value of our columns of interest for each school and then plot just one point per school (with error bars representing variability within the school):","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    error = :School,\n    select = (:MAch, :SSS),\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"By default, this computes the mean and standard error, we can pass estimator = Mean to only compute the mean.","category":"page"},{"location":"generated/tutorial/#Splitting-by-many-variables-1","page":"Tutorial","title":"Splitting by many variables","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can use different attributes to split the data as follows:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(color = :Sx, markershape = :Sector),\n    error = :School,\n    select = (:MAch, :SSS),\n    estimator = Mean,\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#Styling-the-plot-1","page":"Tutorial","title":"Styling the plot","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"There are two ways in which we can style the plot: first, we can pass a custom set of colors instead of the default palette:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    error = :School,\n    select = (:MAch, :SSS),\n    estimator = Mean,\n    color = [:red, :blue]\n    )\nscatter(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Second, we can style plat attributes as we would normally do:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    data,\n    Group(:Sx),\n    error = :School,\n    select = (:MAch, :SSS),\n    estimator = Mean,\n    )\nscatter(args...; legend = :topleft, markersize = 10, kwargs...)","category":"page"},{"location":"generated/tutorial/#Computing-summaries-1","page":"Tutorial","title":"Computing summaries","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"It is also possible to get average value and variability of a given analysis (density, cumulative, hazard rate and local regression are supported so far, but one can also add their own function) across groups.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"For example (here we use ribbon to signal we want a shaded ribbon to denote the error estimate):","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    cumulative,\n    data,\n    Group(:Sx),\n    error = :School,\n    select = :MAch,\n    ribbon = true\n   )\nplot(args...; kwargs..., legend = :topleft)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note that extra keyword arguments can be passed to the analysis:","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    density(bandwidth = 1),\n    data,\n    Group(color=:Sx, linestyle=:Sector),\n    error = :School,\n    select = :MAch,\n    ribbon = true\n   )\nplot(args...; kwargs..., legend = :bottom)","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"If we do not specify error, it defaults to the \"analyses specific error\". For discrete prediction it is the standard error of the mean across observations.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"args, kwargs = series2D(\n    prediction,\n    data,\n    Group(color = :Minrty),\n    select = (:Sx, :MAch),\n)\ngroupedbar(args...; kwargs...)","category":"page"},{"location":"generated/tutorial/#Axis-style-selection-1","page":"Tutorial","title":"Axis style selection","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Analysis try to infer the axis type (continuous if the variable is numeric, categorical otherwise). If that is not appropriate for your data you can use discrete(prediction) or continuous(prediction) (works for hazard, density and cumulative as well).","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interactive_interface/#Interactive-interface-1","page":"Interactive interface","title":"Interactive interface","text":"","category":"section"},{"location":"interactive_interface/#","page":"Interactive interface","title":"Interactive interface","text":"Most of the available analyses can be selected from a simple Interact-based UI. To launch the UI simply do:","category":"page"},{"location":"interactive_interface/#","page":"Interactive interface","title":"Interactive interface","text":"using Recombinase, Interact, StatsPlots, Blink\n# here we give the functions we want to use for plotting\nui = Recombinase.gui(data, [plot, scatter, groupedbar]);\nw = Window()\nbody!(w, ui)","category":"page"},{"location":"interactive_interface/#","page":"Interactive interface","title":"Interactive interface","text":"(Image: interactgui)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"EditURL = \"https://github.com/piever/Recombinase.jl/blob/master/docs/src/digging_deeper.jl\"","category":"page"},{"location":"generated/digging_deeper/#Digging-deeper-1","page":"Digging deeper","title":"Digging deeper","text":"","category":"section"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"The core functioning of Recombinase is based on a set of preimplemented analysis functions and on the OnlineStats package to compute summary statistics efficiently.","category":"page"},{"location":"generated/digging_deeper/#Analysis-functions-1","page":"Digging deeper","title":"Analysis functions","text":"","category":"section"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"Under the hood, the actual computations are implemented in some built-in Analysis objects. Each Analysis takes some vectors (a varying number, one for density and two for prediction for example), an optional axis argument to specify the x axis argument and returns an iterator of (x, y) values, representing the y value corresponding to each point of the x axis.","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using Recombinase: density, hazard, cumulative, prediction\nx = randn(100)\nres = density(x)\ncollect(Iterators.take(res, 5)) # let's see the first few elements","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"We can collect the iterator in a table container to see that we recover the x and y axis, ready for plotting","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using JuliaDB\ns = table(res)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"prediction is similar but requrires two arguments:","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"xs = 10 .* rand(100)\nys = sin.(xs) .+ 0.5 .* rand(100)\n\nres = prediction(xs, ys)\ntable(res)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"The function discrete can turn any analysis into its discrete counter-part (analyses are continuous for numerical axes and discrete otherwise by default). It also automatically comutes the error of the prediction (s.e.m).","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using Recombinase: discrete\n\nx = rand(1:3, 1000)\ny = rand(1000) .+ 0.1 .* x\n\nres = discrete(prediction)(x, y)\ntable(res)","category":"page"},{"location":"generated/digging_deeper/#OnlineStats-integration-1","page":"Digging deeper","title":"OnlineStats integration","text":"","category":"section"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"Summary statistics are computed using the excellent OnlineStats package. First the data is split by the splitting variable (in this case School), then the analysis is computed on each split chunk on the selected column(s). Finally the results from different schools are put together in summary statistics (default is mean and s.e.m):","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"using Recombinase: datafolder, compute_summary\ndata = loadtable(joinpath(datafolder, \"school.csv\"))\ncompute_summary(density, data, :School; select = :MAch)","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"The computation of the summary statistic works in two steps. First statistics from the keyword argument estimator = (Mean, Variance) of compute_summary are computed online, then the function from a keyword argument postprocess = (nobs, mean, var) -> (mean, sqrt(var / nobs)) turn this statistics into values we plot (mean and s.e.m). postprocess needs to take one more argument than the number of statistics of estimator (the number of observations, which is the first argument). To compute a different error bar (for example just the standard deviation) you can simply do:","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"compute_summary(density, data, :School; select = :MAch, postprocess = (nobs, mean, var) -> (mean, sqrt(var)))","category":"page"},{"location":"generated/digging_deeper/#","page":"Digging deeper","title":"Digging deeper","text":"This page was generated using Literate.jl.","category":"page"}]
}
